{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2022-08-18T04:13:56.000Z","updated":"2022-08-18T04:17:31.700Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-18T04:18:10.000Z","updated":"2022-08-18T04:18:55.623Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-08-18T04:36:00.000Z","updated":"2022-08-18T08:48:55.673Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"1234567891011121314151617181920212223242526&#123; &#x27;name&#x27;: &#x27;arczhi&#x27; &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;profession&#x27;: &#x27;Student &amp; Coder&#x27;, &#x27;experience&#x27;: &#x27;学习中&#x27;, &#x27;university&#x27;:&#x27;广州大学&#x27;, &#x27;address&#x27;: &#x27;广东省广州市&#x27;, &#x27;education&#x27;: &#x27;本科&#x27;, &#x27;github&#x27;: &#x27;https://github.com/arczhi&#x27;, &#x27;blog&#x27;: &#x27;http://blog.touchcloud.top&#x27;, &#x27;email&#x27;: &#x27;1225366572@qq.com&#x27;, &#x27;description&#x27;: &#x27;努力努力再努力&#x27;, &#x27;skills&#x27;: [ [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;CSS&#x27;], [&#x27;Vue2&#x27;], [&#x27;Golang&#x27;, &#x27;Gin&#x27;], [&#x27;Python&#x27;, &#x27;Django&#x27;], [&#x27;MySQL&#x27;,&#x27;Redis&#x27;], [&#x27;Docker&#x27;], [&#x27;Photoshop&#x27;] ], &#x27;devTools&#x27;: [&#x27;Visual Studio Code&#x27;, &#x27;Postman&#x27;,&#x27;xftp&#x27;], &#125;"}],"posts":[{"title":"基于websocket的实时聊天功能设计与实现","slug":"实时聊天的设计与实现","date":"2023-01-27T05:31:24.796Z","updated":"2023-02-13T09:32:50.144Z","comments":true,"path":"2023/01/27/实时聊天的设计与实现/","link":"","permalink":"http://example.com/2023/01/27/%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"注：本文的相关设计与实现未经过实际生产环境的验证，仅为作者的探索与实践。 代码仓库： https://github.com/arczhi/EasyChat demo地址： http://touchcloud.top:9999 缘起前段时间在知乎上面刷帖子的时候，偶然看到了websocket这个支持长连接、全双工的协议，它相比短连接、单向的http协议，在某些业务场景下的适用性会更好。比如客户端需要及时知道数据库的某个字段是否更新，传统的做法是客户端不断向服务端发起http请求（轮询），但这会带来不小的网络和资源开销，且由于轮询的间隔时间差，实时性也会有不小的偏差，在此情况下，选择websocket协议会更合适。 当时看到“全双工”，眼睛一下子就亮了，用来websocket来做一个聊天功能应该会很有意思。我很清楚在2023年的今天，网络上一定有很多关于websocket实时聊天的成熟实现，但我觉得不能因为别人把同一样东西做得很好，我们就不去做，相反，在有能力的情况下，一定要试试看能不能做出自己的东西来。 业务逻辑用户在注册完账户后，输入同一个聊天室Key便可进入到同一个聊天室进行聊天。一个聊天室Key相当于一个聊天室，支持双人和多人聊天。 设计 相关名词解释 user_id ：由系统自动生成的id，唯一标识用户。 room_key ： 聊天室的Key。 msg_id：使用雪花算法生成的id，唯一标识消息。 msg_json：存储消息相关信息的JSON字符串。 last_id：客户端所接收的最新一条消息的id。 （1）消息存储 首先，缓存我使用了redis，数据持久化使用了Mysql。 使用有序集合（sorted set）记录每个聊天室的msg_id，key为room_key，score为消息发送时的时间戳，value为msg_id。使用字符串（String）去存储消息的JSON字符串，key为msg_id，value为消息的JSON字符串。维护了两个队列（使用redis的列表List），一个是数据持久化队列，根据队列长度（即消息堆积情况）采取不同的策略，有序地消费消息，将消息写入Mysql，另一个是重试队列，使用指数退避算法，重试数据持久化操作。 12345678910111213141516171819202122232425262728293031323334353637// 数据持久化重试func (m *Msg) DataPersistenceRetry() &#123; //指数退避算法 //重试次数 var retry_times float64 = 1 //随机数 rand_num := 0 //间隙时间 slot_times := 5 * time.Second for retry_times &lt;= 16 &#123; //业务重试 err := m.SaveOne() if err != nil &#123; log.Println(err) &#125; else &#123; break &#125; //等待 //k=Min[重试次数，10] k := retry_times if k &gt; 10 &#123; k = 10 &#125; //使用雪花算法生成的id作为随机数种子 rand.Seed(sf.GenID()) //rand.Intn() 返回的随机数范围为 [0,n) ,即此处生成的随机数范围为(2^k)-1 rand_num = rand.Intn(int(math.Pow(2, k))) for i := 0; i &lt; rand_num; i++ &#123; time.Sleep(slot_times) &#125; //重试次数加一 retry_times++ &#125;&#125; （2）消息收发 既然是实时聊天，那客户端必然是要不断地与服务端交互，以获取最新的数据。在我的实现里面，参考了Feeds流系统的相关设计，客户端并不是从服务端拉取数据，而是由服务端推送数据。客户端不断地向服务端发送last_id（即客户端所接收的最新一条消息的id，服务端将其以字符串的形式存储在redis中），服务端根据last_id来判断数据库中是否有新的数据需要发送给客户端，有则发送，无则忽略。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 消息接收与发送func handle(conn *websocket.Conn) &#123; //(1)持续向客户端发送消息 go func() &#123; for &#123; // 业务逻辑 sendMsg() ...... &#125; &#125;() //(2)挂起并接收客户端的消息 for &#123; msg := &amp;models.Msg&#123;&#125; msgType, data, err := conn.ReadMessage() if err != nil &#123; log.Println(err) &#125; //正常接收消息的情况下，msgType可能是1或其他数字 //若msgType为-1，则证明浏览器已经主动将连接关闭 if msgType == -1 &#123; //当客户端主动关闭连接时，删除last_id removeLastId(user_id, room_key) return &#125; //根据接收数据的前面一部分的内容，来区分执行相关操作 //(i) 初始化连接，接收last_id(初始化为11111111)、room_key、用户id if string(data[0]) == &quot;i&quot; &#123; // 业务逻辑 ...... &#125; //(ii) 接收Msg if string(data[0]) == &quot;&#123;&quot; &#123; // 业务逻辑 ...... //缓存消息 ...... //数据持久化 ...... &#125; //(iii) 接收last_id if string(data[0]) != &quot;[&quot; &amp;&amp; string(data[0]) != &quot;&#123;&quot; &#123; // 业务逻辑 ...... &#125; &#125;&#125; 但这种由服务端推送数据的模式，在实际的开发过程中很容易遇到推送重复数据的问题，而且该问题容易在客户端与服务端初始化websocket连接的时候发生。经过排查，发现是客户端（前端）代码里面连续向服务端发送last_id的时机问题，需要设置一小段等待时间，等待客户端成功接收到服务端首次发送的数据。 12345678910111213setTimeout(()=&gt;&#123; //顺利获取所有消息后，定期将向服务端发送接收到的最后一条消息的id (last_id) self.setInterval( function sendLastId()&#123; var last_id = 11111111 if ( _this.ReceiveMsgList.length != 0 )&#123; last_id = _this.ReceiveMsgList[_this.ReceiveMsgList.length-1].id &#125; socket.send(last_id) &#125;,200 ) //ms&#125;,1000) //ms 一段时间后才启动setInterval，等待客户端接收到第一次消息数据 参考：《周末小技 | 开发一个Feeds流系统——写扩散模式》 https://mp.weixin.qq.com/s/P905LOBgRljDmpMYR_nI1w （3）缓存 为了降低缓存雪崩的可能，服务端根据聊天室中过去24小时的消息数目，动态设置相关key的过期时间。 12345678910111213141516//查询Mysql中近24小时的消息数量msg_num, err := m.CountLatestNum(m.RoomKey, time.Now().Add(-24*time.Hour))if err != nil &#123; return err&#125;//根据消息数量设置响应的缓存时间msg_expire := 1if 0 &lt;= msg_num &amp;&amp; msg_num &lt;= 30 &#123; msg_expire = 2 * ExpireWeight&#125;if 30 &lt; msg_num &amp;&amp; msg_num &lt;= 100 &#123; msg_expire = 6 * ExpireWeight&#125;if 100 &lt; msg_num &#123; msg_expire = 12 * ExpireWeight&#125; 开发问题（1）session跨域问题 服务端的程序需要在客户端存储携带有sessionID的cookie时，会受到CORS协议的严格控制，需要同时修改客户端和服务端的代码。 客户端这里，需要开启“withCredentials”，我使用了vue2，并使用axios发起http请求，配置如下： 1axios.defaults.withCredentials = true 服务端这里，需要添加相关的http响应头，尤其是设置”Access-Control-Allow-Origin”，我这里使用了go语言的http标准库，配置如下： 1234w.Header().Add(&quot;Access-Control-Allow-Origin&quot;, &quot;这里填客户端的域&quot;)w.Header().Add(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-CSRF-Token, Authorization, Token&quot;)w.Header().Add(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, PUT, DELETE ,OPTIONS&quot;)w.Header().Add(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;) 按照网上帖子，完成上述两步操作即可解决问题。但是在我的实践过程中，问题并未解决。根据浏览器调试工具的提示，我还需要设置cookie的相关属性。 1）设置合适的域 2）开启Secure选项 3）将same-site属性为None，允许跨站点使用 123456//设置域Store.Options.Domain = config.Cfg.HOSTNAME //默认为127.0.0.1//同时开启secure选项Store.Options.Secure = true//设置same-site属性为None 允许跨站点使用Store.Options.SameSite = http.SameSiteNoneMode （2）依赖库 “github.com&#x2F;gorilla&#x2F;sessions” 重启应用后校验session非法的问题 本次开发的用户鉴权使用了session，在调试过程中，该依赖库经常会出现如下报错： 12023/01/21 20:28:38 securecookie: the value is not valid 后面参考了github的issue，发现是设置session时，配置的密钥存在问题，不应该使用随机的key，而应使用固定的key，否则每次重启应用，读取上次的session就会非法。 按照官方的样例进行配置（使用了随机的Key）： 12var Store *sessions.FilesystemStoreStore = sessions.NewFilesystemStore(path, securecookie.GenerateRandomKey(32), securecookie.GenerateRandomKey(32)) 我们在实际应用中需要修改，使用固定的Key： 12var Store *sessions.FilesystemStoreStore = sessions.NewFilesystemStore(path, KeyForSecureCookie, KeyForSecureCookie) 参考：https://github.com/gorilla/sessions/issues/16 （3）缓存与非缓存数据混合提取、分页加载 这个问题暂时还没能解决，现在提取数据要么是全量提取Mysql，要么是全量提取redis，还没办法做到根据消息的创建时间，先缓存一部分热点数据，提取数据的时候，先提redis的数据，等用户上翻滚动条到非热点数据时，再提Mysql。 感想实际开发的过程中才体会到，缓存并不像PPT那样说加就加，缓存数据和持久数据的数据一致性、缓存数据的过期时间等等，有很多需要考虑的问题，而且为了实现一段业务逻辑，不仅需要为mysql写一套代码逻辑，同时还需要为redis写一套代码逻辑，就开发难度和后期维护而言，成本是增加了的。后面我打算了解一下关于缓存的成熟解决方案，看一下大牛们是怎么做的。","categories":[{"name":"前后端开发","slug":"前后端开发","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"},{"name":"Vue2","slug":"Vue2","permalink":"http://example.com/tags/Vue2/"},{"name":"SESSION","slug":"SESSION","permalink":"http://example.com/tags/SESSION/"}]},{"title":"记一次实战开发","slug":"记一次实战开发","date":"2022-12-31T00:59:57.055Z","updated":"2023-01-27T05:33:08.034Z","comments":true,"path":"2022/12/31/记一次实战开发/","link":"","permalink":"http://example.com/2022/12/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%9E%E6%88%98%E5%BC%80%E5%8F%91/","excerpt":"","text":"为保护项目隐私，本文中的相关名词都做了模糊化处理 起始 ​ 今年九月，刚开学的时候，我联系了一位老师，希望能尝试一些项目，老师很支持。于是十月份的时候，课题来了，我上手了这次的开发，主要负责后端。 ​ 前前后后开了两次正式的需求座谈会，项目前期的需求并不多，其实就两个大的方向：一个用户管理模块和一个业务模块。 起步 ​ 开发的起步阶段是比较顺利的，因为之前我也尝试过类似的用户管理模块，而且业务模块的实现也并不复杂。唯一让我比较有压力的是上线时间，正式开发是10月20号，但上线时间定在了十一月初。快马加鞭，我花了大概两天的时间，实现了基本的登录注册、权限控制，又花了大概三天去实现我们的业务模块，也就是说，从正式开始到基本功能的实现，只花了一周的时间。 中期 ​ 十月底，那是第二次需求座谈会。在会上，因为一些政策问题，我们开发的应用必须要获得等级保护认证才能收集用户的隐私信息，比如身份证和手机号。但项目急于上线，无奈，我们不得不放弃对于这些信息的收集，重新设计用户表。当时一开始是希望使用用户的身份证去唯一标识用户，但失去了身份证作为ID，我只好使用一些更为常用的方法。好在更改之后的数据库设计变动不算特别大，落实到代码层面也就是修改几个变量和逻辑。 ​ 中途，业务模块那边又多了一个新的需求，大概就是有一个核心的业务操作需要针对一个特定地区有特定的操作。把这个需求实现并没有多困难，只是我那时候没有意识到，繁琐的是后续的开发，后续所有涉及该业务操作的代码都要做两份，一份通用代码，一份是针对性的代码。 后期 ​ 来到后期，后端开发这边也没有太多要做的，主要还是不断地测试、优化，找出代码逻辑里面致命性的地方。 ​ 那个时候老师提了一个建议，说可以考虑用redis来提高业务操作的并发。我灵机一动，使用redis和消息队列重新设计了核心业务的代码逻辑。一开始，用户的请求来了之后，是直接修改数据库操作，并发量上来之后，数据库操作这里肯定会成为响应速度的瓶颈，我使用接口测试工具多次测试，响应速度大概在230ms。但修改逻辑之后，用户请求过来，先把请求的数据给缓存到redis里面，然后使用消息队列，生产者发送用户的请求数据，消费者消费请求数据，完成最后的数据库持久化。于是乎，整个业务操作与响应解耦，响应时间被缩短到了100ms以内。多次测试，消息队列也并没有出现丢消息的情况。不过为了保险起见，我还是维护了一份直接进行数据库操作的代码，并在后续上线的时候，把这份代码作为backup进行了部署。 ​ 由于整个开发过程的基调就是“快速”，所以我每次代码review的时候总能发现很多小问题，比如某些指代信息的变量不小心null掉了，但仍然随着后面的代码逻辑继续进行，导致了一些bug。像这种还好，出现过最恐怖的问题是这个，还好问题在上线之前就被发现了，就是在某个业务操作的地方，代码会进入一个循环，直到业务操作结束。这里使用一个循环是没问题的，但问题就在于我没有在循环里面使用睡眠操作，比如sleep操作，这就直接导致了CPU不停地空转，占用率从一开始的3%，直线飙升到95%。如果这个问题在上线之后才暴露出来，那后果简直不敢想象。所以后来，每当代码里面涉及循环，我都会多问一问自己，这个循环有没有信心能够准确退出？会不会过度消耗机器资源？ 带宽窒息 ​ 我从来没想过，我们的应用在上线的第一天，八点开始，短短两个小时就“离奇”崩溃了。 ​ 云厂商的监控一直在告警，说带宽超过限度，机器配置是10M，但实际已经用到11M。十点钟的课，我人都还没到教室，在楼下等电梯。没办法，排着队，从背包里面掏出笔记本，赶忙看一下我在上线前给应用接入的prometheus监控，CPU占用正常、内存占用正常，请求量只有几十个，不多啊。怎么带宽就会突然爆掉？后面我又尝试重启应用，并没有效果，带宽仍然处于高负荷状态。 ​ 到了11点，我不经意地怀疑了一下，有没有可能是前端应用的问题？结果打开控制台，检查网络请求，怪事，但是一个首页的加载就要请求整整12M的资源，这不要说10M的机器，哪怕100M的机器也顶不住啊。于是紧急联系了负责前端开发的同学，去对静态资源进行压缩，优化之后，首页加载的资源只有900k。晚上不放心，又接入了CDN，去缓解源站的资源请求压力。 ​ 感觉上，这不是一个技术难度很高的问题，但却是一个非常影响用户体验的问题，并且由于测试环境中的测试样本太少，导致带宽的高占用没有暴露出来，值得敲响警钟，一定要在测试阶段尽可能地模拟用户数量。 上线 ​ 也许只有当你真正尝试过把应用发布上线，你才能懂得“混乱不堪”的这个词的含义。 ​ 当应用真正交给用户使用之后，用户的操作对于开发者来说完全是黑箱，你只能通过用户只言片语的反馈中，来重新寻找自己代码的逻辑问题。很多时候，我反复地在“用户操作”和“代码逻辑”之间纠结，究竟是用户误操作了呢，还是我的代码逻辑出问题了呢？上线之后，用户反馈的最多的问题就是“某某入口，点击之后进不去”。这个问题就很奇妙了，首先，并不是所有用户都进不去，因为我在监控里面也是可以看到有正常的业务操作的。那，有没有可能是用户在某个步骤操作错误，所以导致了问题呢？当然，除了给用户提供建议，我也会不断地review我的代码。 ​ 这个时候，我觉得日志和监控真的真的很关键。日志可以告诉你发生了什么，错误出现在什么时候、哪个地方，我的建议是，日志最好还要对接一下你的业务，你除了需要知道你的代码出现了什么错误，你还要知道你的错误是由哪个用户的操作引起的，这样可以帮助你和用户及时沟通，从他们的反馈中获得一些判断信息。监控的重要性更加是不言而喻，监控保证了应用的运行状况对于你而言是透明的、可观测的，为你的运维提供了很大的便利。 ​ 截至目前，本次开发的应用已经稳定完成了甲方目标业务的1&#x2F;3，剩下的目标需要等待甲方去完成。 变数 ​ “唯一确定的就是不确定的人生” ——罗翔老师 ​ 很多事情都一样，各种不确定，各种变化才是常态。我们没办法总是像预期一样，让所有事情都水到渠成。怎么样才能处变不惊，这需要功夫，需要不断地打磨自己。下一步，我不知道会怎么变化，但我会努力把眼前的这一步，先走好。","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"Go socket编程学习","slug":"golang socket编程学习","date":"2022-09-24T02:43:44.800Z","updated":"2022-12-20T08:49:16.821Z","comments":true,"path":"2022/09/24/golang socket编程学习/","link":"","permalink":"http://example.com/2022/09/24/golang%20socket%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"体验socket编程并尝试调优 简单的客户端和服务端 server发送数据（随机数），client接收 server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;encoding/binary&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;net&quot; &quot;time&quot;)var socket = &quot;:9066&quot;var BufLen = 1024 //缓存（字节数组）长度//处理连接func HandleConnection(conn net.Conn) &#123; defer conn.Close() rand.Seed(time.Now().UnixNano()) var startTime = time.Now() //进行随机数发送 for time.Now().Sub(startTime) &lt;= 10*time.Second &#123; buf := make([]byte, BufLen) binary.PutVarint(buf, rand.Int63()) //注意，这里是可变长编码 conn.Write(buf) &#125;&#125;//调整缓存长度func AjustBufLen() &#123; fmt.Printf(&quot;Please change the BufLen: &quot;) fmt.Scanln(&amp;BufLen) fmt.Printf(&quot;Current []byte Len \\t%d\\n&quot;, BufLen)&#125;func main() &#123; //创建tcp连接，监听端口 listen, err := net.Listen(&quot;tcp&quot;, socket) if err != nil &#123; fmt.Printf(&quot;[ERROR] Listen err: %v\\n&quot;, err) return &#125; fmt.Printf(&quot;[server] Server listening %v\\n&quot;, socket) //调整写入缓存的长度 AjustBufLen() //处理连接 for &#123; con, err := listen.Accept() if err != nil &#123; fmt.Printf(&quot;[ERROR] Accept err: %v\\n&quot;, err) continue &#125; //开启新协程，去处理客户端连接 go HandleConnection(con) &#125;&#125; client 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net&quot; &quot;time&quot;)var socket = &quot;:9066&quot;func main() &#123; //与服务端建立连接 conn, err := net.Dial(&quot;tcp&quot;, socket) if err != nil &#123; fmt.Printf(&quot;[ERROR] Error connection : %v\\n&quot;, err) return &#125; defer conn.Close() //退出前关闭连接 //接收响应,读取数据 var totalBytes int var startTime = time.Now() bytes, err := ioutil.ReadAll(conn) if err != nil &#123; fmt.Printf(&quot;[ERROR] Error reading : %v\\n&quot;, err) return &#125; totalBytes = len(bytes) cost := time.Now().Sub(startTime).Seconds() fmt.Printf(&quot;[analysis]\\nReceived\\t%d\\t\\tbytes \\nEquals\\t\\t%d\\tbits \\nTime Cost\\t%v\\ts \\nAverage Speed\\t%v\\t\\tMB/s\\n &quot;, totalBytes, totalBytes*8, cost, fmt.Sprintf(&quot;%.2f&quot;, float64(totalBytes)/1024/1024/cost))&#125; 效果演示 可以看到速度并不理想 此时条件: server端使用了长度为10的byte切片作为缓存（每次循环要发送的数据大小）; client端使用ioutil.ReadAll()对数据全部读取； server端持续发送数据 10 s ； 本地回环测试； 问题回顾1.varint变长编码 123buf := make([]byte, 8) binary.PutVarint(buf, rand.Int63())conn.Write(buf) 这里使用了一个长度为8的byte切片，尝试向其中写入一个int64的随机数，但是报错了。按道理来说，byte为uint8，占1个字节，int64占8个字节，长度为8的byte切片理应可以存储一个int64的数，为什么会报错呢？ 仔细观察，发现我所使用的binary的方法为PutVarint（int64转换成[]byte），这个Varint，百度之后，原来是一种变长编码，能够实现很好的编码压缩效果（小数字占用较少字节，大数字占用较多的字节，但小数字出现的频率更高）。 除了最后一个字节外，varint编码中的每一个字节都有一个最高有效位most significant bit (MSB)，它告诉了我们是否还有更多的字节。若MSB为1，则还有更多的字节；若MSB为0，则到这里为止。一个字节中，除了这个最高有效位，其余7位均采用二进制补码的形式存储，最低有效组在前，或者叫最低有效字节在前（即小端序排列）。 这意味着，长度为8的[]byte切片，使用Varint编码，只有 8 * 7 &#x3D; 56 个有效位，无法存储一个64位的int64，至少需要长度为10的byte切片 (10 * 7 &#x3D; 70) 才能存储一个int64的数。 参考 Encoding | Protocol Buffers | Google Developers protobuf中关于varint有很棒的解释 详解varint编码原理 - 知乎 (zhihu.com) 该帖子也很不错 2.性能调优 调整服务端写入缓冲区的大小 12//将写入缓冲区的字节数调整为 10conn.SetWriteBuffer(10) 若写入缓存小于要发送的数据大小，则write()&#x2F;send()会被阻塞，直到缓存区中的数据被发送到目标机器，腾出足够空间，write()&#x2F;send()才会继续写入数据。 参考： (104条消息) golang tcp write阻塞_socket缓冲区以及阻塞模式详解_weixin_39521651的博客-CSDN博客 从 0.37MB&#x2F;s 到 0.62MB&#x2F;s，有一定的速度提升。（精确测试应多次测量取平均值） 调整客户端读取缓冲区的大小(保持前述调整) 12//修改读取缓冲区的字节数调整为 1 ，不必等到默认的8字节再开始读取数据conn.SetReadBuffer(1) 参考：golang 网络编程 设置读写缓冲区的大小 - 方东信 - 博客园 (cnblogs.com) 提升不算明显 提高随机数编码的缓存大小 调整BufLen 12buf := make([]byte, BufLen) binary.PutVarint(buf, rand.Int63()) 可以看到，随着缓存的提高，速度也在提高。 但当缓存增大到一定值后，出现了虚拟内存分配的错误: 12runtime: VirtualAlloc of 1147486208 bytes failed with errno=1455fatal error: out of memory 解决方案等待补充 ………… 调整后的代码 server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( &quot;encoding/binary&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;net&quot; &quot;time&quot;)var socket = &quot;:9066&quot;var BufLen = 10 //缓存（字节数组）长度func HandleConnection(conn *net.TCPConn) &#123; //退出前关闭连接 defer conn.Close() //随机数种子 rand.Seed(time.Now().UnixNano()) //将写入缓存的字节数调整为10 conn.SetWriteBuffer(10) var startTime = time.Now() //进行随机数发送 for time.Now().Sub(startTime) &lt;= 10*time.Second &#123; buf := make([]byte, BufLen) binary.PutVarint(buf, rand.Int63()) //可变长编码 conn.Write(buf) &#125;&#125;func AjustBufLen() &#123; fmt.Printf(&quot;Please change the BufLen: &quot;) fmt.Scanln(&amp;BufLen) fmt.Printf(&quot;Current []byte Len \\t%d\\n&quot;, BufLen)&#125;func main() &#123; //创建tcp连接，监听端口 tcpAddr, _ := net.ResolveTCPAddr(&quot;tcp&quot;, socket) listen, err := net.ListenTCP(&quot;tcp&quot;, tcpAddr) if err != nil &#123; fmt.Printf(&quot;[ERROR] Listen err: %v\\n&quot;, err) return &#125; fmt.Printf(&quot;[server] Server listening %v\\n&quot;, socket) //调整写入缓存的长度 AjustBufLen() //处理连接 for &#123; con, err := listen.AcceptTCP() if err != nil &#123; fmt.Printf(&quot;[ERROR] Accept err: %v\\n&quot;, err) continue &#125; //开启新协程，去处理客户端连接 go HandleConnection(con) &#125;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net&quot; &quot;time&quot;)func main() &#123; socket := &quot;:9066&quot; tcpAddr, err := net.ResolveTCPAddr(&quot;tcp&quot;, socket) conn, err := net.DialTCP(&quot;tcp&quot;, nil, tcpAddr) if err != nil &#123; fmt.Printf(&quot;[ERROR] Error connection : %v\\n&quot;, err) return &#125; defer conn.Close() //退出前关闭连接 //接收响应 var startTime = time.Now() //修改读取缓冲区的大小 conn.SetReadBuffer(1) //全部读取 bytes, err := ioutil.ReadAll(conn) if err != nil &#123; fmt.Printf(&quot;[ERROR] Error reading : %v\\n&quot;, err) return &#125; totalBytes := len(bytes) cost := time.Now().Sub(startTime).Seconds() fmt.Printf(&quot;[analysis]\\nReceived\\t%d\\t\\tbytes \\nEquals\\t\\t%d\\tbits \\nTime Cost\\t%v\\ts \\nAverage Speed\\t%v\\t\\tMB/s\\n &quot;, totalBytes, totalBytes*8, cost, fmt.Sprintf(&quot;%.2f&quot;, float64(totalBytes)/1024/1024/cost))&#125;","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Go jwt应用实践","slug":"jwt应用实践","date":"2022-09-15T00:05:00.570Z","updated":"2022-12-20T08:55:54.648Z","comments":true,"path":"2022/09/15/jwt应用实践/","link":"","permalink":"http://example.com/2022/09/15/jwt%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"Json Web Token JSON Web Token Introduction - jwt.io 什么是 JWT – JSON WEB TOKEN - 简书 (jianshu.com) 思路学习的博客地址 (103条消息) vue3+golang-jwt前后端分离实现token验证_online、的博客-CSDN博客 实际操作 使用 “github.com&#x2F;dgrijalva&#x2F;jwt-go” 生成jwt，并编写测试接口获取和校验jwt。 1.封装创建token的函数 创建步骤参考jwt-go的样例文件 https://github.com/dgrijalva/jwt-go/blob/master/example_test.go 1234567891011121314151617181920212223242526272829303132//自定义声明type Claim struct &#123; Username string `json:&quot;username&quot;` Uid uint `json:&quot;uid&quot;` jwt.StandardClaims&#125;//私有签名Keyvar mySigningKey = []byte(&quot;key of arczhi&quot;)func CreateToken(username string, uid uint) (ctoken string, err error) &#123; claim := Claim&#123; Username: username, Uid: uid, StandardClaims: jwt.StandardClaims&#123; NotBefore: time.Now().Unix() - 60, //生效时间，这里是一分钟前生效 ExpiresAt: time.Now().Unix() + 2*60, Issuer: &quot;arczhi&quot;, &#125;, &#125; token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim) ctoken, err = token.SignedString(mySigningKey) //生成完整的、签名后的token if err != nil &#123; log.Fatal(&quot;Error token signing\\n&quot;, err) &#125; return ctoken, nil&#125; 2.编写测试接口 测试接口 12http.HandleFunc(&quot;/GetToken&quot;, getToken)http.HandleFunc(&quot;/GetData&quot;, Photo) &#x2F;GetToken 1234567891011121314151617181920212223242526272829303132333435363738func getToken(w http.ResponseWriter, r *http.Request) &#123; if r.Method == &quot;POST&quot; &#123; //读取http Body buf, err := ioutil.ReadAll(r.Body) if err != nil &#123; w.WriteHeader(500) io.WriteString(w, &quot;body read error&quot;) return &#125; defer r.Body.Close() //读完数据后，记得延迟关闭请求体！ //解码json字符串，储存在对象中 var user Token.Claim err1 := json.Unmarshal(buf, &amp;user) if err1 != nil &#123; w.WriteHeader(500) fmt.Println(err1) io.WriteString(w, &quot;json Unmarshal Error&quot;) return &#125; //调用封装的函数，创建token token, err := Token.CreateToken(user.Username, user.Uid) if err != nil &#123; w.WriteHeader(500) io.WriteString(w, &quot;error creating token&quot;) return &#125; fmt.Fprintf(w, ToJSON(KV&#123;&quot;usernme&quot;: user.Username, &quot;uid&quot;: user.Uid, &quot;token&quot;: token&#125;)) &#125; else &#123; w.WriteHeader(404) io.WriteString(w, &quot;Not Found&quot;) return &#125;&#125; &#x2F;GetData 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func Photo(w http.ResponseWriter, r *http.Request) &#123; if r.Method == &quot;POST&quot; &#123; //获取http报文header中的Authorization字段 auth := r.Header.Get(&quot;Authorization&quot;) if auth == &quot;&quot; &#123; w.WriteHeader(401) io.WriteString(w, &quot;no authorization&quot;) return &#125; //解析token 该函数需要三个参数：token字符串、结构体jwt.Claims的实例、一个指定func vertifyToken, err := jwt.ParseWithClaims(auth, &amp;Token.Claim&#123;&#125;, func(token *jwt.Token) (interface&#123;&#125;, error) &#123; // since we only use the one private key to sign the tokens, // we also only use its public counter part to verify return []byte(&quot;key of arczhi&quot;), nil &#125;) if err != nil &#123; fmt.Println(err) w.WriteHeader(500) io.WriteString(w, ToJSON(KV&#123;&quot;msg&quot;: fmt.Sprintf(&quot;%v&quot;, err)&#125;)) return &#125; //获取验证后的token中的声明 claim := vertifyToken.Claims.(*Token.Claim) //test fmt.Println(claim) //匹配uid和token签发者 if claim.Uid == 1012 &amp;&amp; claim.Issuer == &quot;arczhi&quot; &#123; //token合法 fmt.Println(&quot;token ok!&quot;) //设置Header字段 w.Header().Set(&quot;Content-Type&quot;, &quot;image/jpeg&quot;) //或者multipart/form-data //读取文件 fileByte, err := os.ReadFile(&quot;./uploadFile/gzhu.jpg&quot;) if err != nil &#123; w.WriteHeader(500) io.WriteString(w, &quot;internal error&quot;) return &#125; //将字节数组写入http响应报文的Body中 w.Write(fileByte) &#125; else &#123; fmt.Println(err) w.WriteHeader(404) io.WriteString(w, &quot;token invalid&quot;) return &#125; &#125; else &#123; w.WriteHeader(404) io.WriteString(w, &quot;Not Found&quot;) return &#125;&#125; 3.使用postman测试对应接口 获取token Header中添加Authorization字段，并填入token，验证通过，在响应报文中得到图片 若token过期","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Go 操作Redis缓存JSON数据的实践","slug":"Go 操作redis缓存JSON数据-实践","date":"2022-09-07T07:54:17.100Z","updated":"2022-09-27T08:53:09.284Z","comments":true,"path":"2022/09/07/Go 操作redis缓存JSON数据-实践/","link":"","permalink":"http://example.com/2022/09/07/Go%20%E6%93%8D%E4%BD%9Credis%E7%BC%93%E5%AD%98JSON%E6%95%B0%E6%8D%AE-%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"使用第三方库 redigo1go get github.com/gomodule/redigo/redis 1.创建Redis连接池1234567891011121314151617181920212223242526272829303132333435363738394041424344package databaseimport ( &quot;fmt&quot; &quot;log&quot; &quot;time&quot; &quot;github.com/garyburd/redigo/redis&quot;)var RedisConf = map[string]string&#123; &quot;name&quot;: &quot;redis&quot;, &quot;type&quot;: &quot;tcp&quot;, &quot;address&quot;: &quot;your_domain:6379&quot;, &quot;auth&quot;: &quot;your_password&quot;,&#125;var RedisClient *redis.Pool //从database这个包中公开func InitRedisPool() &#123; // 建立连接池 实例化一个包里面的Pool结构体 RedisClient = &amp;redis.Pool&#123; // 从配置文件获取maxidle以及maxactive，取不到则用后面的默认值 MaxIdle: 16, //最初的连接数量 // MaxActive:1000000, //最大连接数量 MaxActive: 0, //连接池最大连接数量,不确定可以用0（0表示自动定义），按需分配 IdleTimeout: 300 * time.Second, //连接关闭时间 300秒 （300秒不使用自动关闭） Dial: func() (redis.Conn, error) &#123; //要连接的redis数据库 //创建redis连接,指定连接0号数据库 //shell命令 : redis-cli -h 127.0.0.1 -p 6379 -n 0 -xxxxxx con, err := redis.Dial(RedisConf[&quot;type&quot;], RedisConf[&quot;address&quot;], redis.DialDatabase(0), redis.DialPassword(RedisConf[&quot;auth&quot;])) if err != nil &#123; log.Fatal(&quot;[ERROR] Failed to initialize the Redis database.\\n&quot;, err) return nil, err &#125; fmt.Printf(&quot;[OK] Successfully connected to the Redis database.\\n&quot;) return con, nil &#125;, &#125;&#125; 2.封装缓存操作函数 我的思路，封装两个函数：一个用于查询缓存，一个用于设置缓存。 两个函数均设置三个形式参数： c *gin.Context （用来传入controller 的 *gin.Context 变量，方便在此函数中发起http响应） any interface{} (interface{} 类型的变量，用来接收传入的map、struct等对象) record string （传入要查询或者设置的Redis中的key） 使用Redis的字符串结构 （SET key value 和 GET key value） CheckCache()负责查询指定的record（key），将储存在redis中的JSON字符串（以Byte数组的形式）提取出来，然后使用JSON.Unmarshal()方法，将解析好的结果保存在interface{}类型的对象中（可能是struct、map 等等）。此外，这里还设置了一个bool返回值，来确定缓存是否存在。 SetCache()负责将传入的interface{}对象，序列化为JSON字符串（借助JSON.Marshal()方法）并存储在Redis中。 CheckCache() 12345678910111213141516171819202122232425262728293031var EXPIRE = 10 //缓存时间func CheckCache(c *gin.Context, any interface&#123;&#125;, record string) bool &#123; rc := database.RedisClient.Get() //从连接池中创建连接 defer rc.Close() //记得退出前关闭数据库连接 result, _ := redis.Bytes(rc.Do(&quot;GET&quot;, record)) //example : var user User //result（byte数组的长度为空） if len(result) == 0 &#123; fmt.Println(&quot;\\&quot;msg\\&quot;:\\&quot;cache missing!\\&quot;&quot;) return false &#125; //反序列化，存储在结构体等对象中 err := json.Unmarshal(result, &amp;any) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;msg&quot;: &quot;json Unmarshal ERROR!&quot;&#125;) fmt.Printf(&quot;[ERROR] %v\\n&quot;, err) panic(&quot;json 反序列化出错&quot;) &#125; if &amp;any != nil &#123; c.JSON(http.StatusOK, &amp;any) fmt.Println(&quot;\\&quot;msg\\&quot;:\\&quot;cache hit!\\&quot;&quot;) return true &#125; return false&#125; SetCache() 1234567891011121314151617func SetCache(c *gin.Context, any interface&#123;&#125;, record string) &#123; rc := database.RedisClient.Get() defer rc.Close() //记得退出前关闭数据库连接 //对数据进行json序列化，转成json字符串 jsonData, err := json.Marshal(any) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;msg&quot;: &quot;json Marshal ERROR!&quot;&#125;) fmt.Printf(&quot;[ERROR] %v\\n&quot;, err) panic(&quot;json 序列化出错\\n&quot;) &#125; _, err1 := rc.Do(&quot;SET&quot;, record, jsonData, &quot;EX&quot;, EXPIRE) if err1 != nil &#123; panic(&quot;[ERROR] redis do error!&quot;) &#125; fmt.Println(&quot;\\&quot;msg\\&quot;:\\&quot;cache set!\\&quot;&quot;)&#125; 3.实际应用 在涉及对MySQL操作的之前调用CheckCache(),之后通过判断缓存的存在与否来决定是否调用SetCache() 实践 123456789101112131415161718192021222324252627//准备结构体数组var ( users []*models.User err error)//先查询Redis缓存record := &quot;key_to_query&quot;cache := models.CheckCache(c, users, record)//缓存存在，终止函数if cache &#123; return&#125;//缓存不存在，查询MySQL数据库users, err = models.AllUserQuery()if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;code&quot;: &quot;code1&quot;&#125;) return&#125;//若无缓存，则设置if !cache &#123; models.SetCache(c, users, record)&#125;","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"Go goroutine读取字典的并发安全问题[fatal error:concurrent map writes]","slug":"go并发安全问题_fatal error concurrent map writes map","date":"2022-08-31T08:15:45.878Z","updated":"2022-12-20T08:55:20.713Z","comments":true,"path":"2022/08/31/go并发安全问题_fatal error concurrent map writes map/","link":"","permalink":"http://example.com/2022/08/31/go%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98_fatal%20error%20concurrent%20map%20writes%20map/","excerpt":"","text":"背景 前段时间想起班委平时重命名作业很麻烦，于是想着写一个小程序。作业重命名的场景刚好可以使用golang的协程，体验一下并发编程带来的速度提升。 arczhi&#x2F;GoRename: 一个作业规范重命名工具 A homework renaming tool (github.com) 问题 但是在使用协程的过程中，由于每一个goroutine都涉及到一个字典（全局变量format）的读取，但我并没有加锁，直接导致异常的抛出。fatal error: concurrent map writes。原来并发访问map是不安全的，会出现未定义行为，导致程序退出。https://cloud.tencent.com/developer/article/1821143 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var ( myFolder string //待处理目录 id string //学号 class string //班级 peopleName string //姓名 chapter string //作业章节 formatChoice string //格式 WG sync.WaitGroup)//作业格式var format = map[string]string&#123; &quot;0&quot;: id, &quot;1&quot;: peopleName, &quot;2&quot;: class, &quot;3&quot;: chapter,&#125;func main() &#123; ............. //开启协程 go func() &#123; //退出前关闭一个wg defer WG.Done() //fmt.Println(f.Name()) //属于文件，先进行匹配查询，查询成功则重命名 var ok bool peopleName, id, ok = Check.NameCheck(f.Name()) if ok &#123; //新旧文件路径 oldPath := fmt.Sprintf(&quot;%v/%v&quot;, myFolder, f.Name()) newPath := fmt.Sprintf(&quot;%v/%v %v %v %v %v&quot;, myFolder, format[strings.Split(formatChoice, &quot;&quot;)[0]], format[strings.Split(formatChoice, &quot;&quot;)[1]], format[strings.Split(formatChoice, &quot;&quot;)[2]], format[strings.Split(formatChoice, &quot;&quot;)[3]], path.Ext(oldPath)) //重命名 err := os.Rename(oldPath, newPath) if err != nil &#123; fmt.Println(err) &#125; &#125; &#125;() .............&#125; 解决 尝试使用 sync.Mutex 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//一些变量var ( myFolder string //待处理目录 id string //学号 class string //班级 peopleName string //姓名 chapter string //作业章节 formatChoice string //格式 WG sync.WaitGroup MUTEX sync.Mutex)//作业格式var format = map[string]string&#123; &quot;0&quot;: id, &quot;1&quot;: peopleName, &quot;2&quot;: class, &quot;3&quot;: chapter,&#125;func main() &#123; ......... //开启协程 go func() &#123; //退出前关闭一个wg defer WG.Done() //fmt.Println(f.Name()) //属于文件，先进行匹配查询，查询成功则重命名 var ok bool peopleName, id, ok = Check.NameCheck(f.Name()) if ok &#123; //fmt.Println(format) //新旧文件路径 oldPath := fmt.Sprintf(&quot;%v/%v&quot;, myFolder, f.Name()) //上锁 MUTEX.Lock() newPath := fmt.Sprintf(&quot;%v/%v %v %v %v %v&quot;, myFolder, format[strings.Split(formatChoice, &quot;&quot;)[0]], format[strings.Split(formatChoice, &quot;&quot;)[1]], format[strings.Split(formatChoice, &quot;&quot;)[2]], format[strings.Split(formatChoice, &quot;&quot;)[3]], path.Ext(oldPath)) //重命名 err := os.Rename(oldPath, newPath) if err != nil &#123; fmt.Println(err) &#125; //解锁 MUTEX.Unlock() &#125; &#125;() .........&#125; 程序执行正常，问题成功解决 分析 多协程同时读取临界资源会存在并发安全问题，必须要上锁（设置临界区）来避免。 但由于上锁，各个协程先后读取字典format，整体重命名的操作被极大地拖慢，总用时112.1486ms。 于是我尝试在每个goroutine中单独定义一个字典format，本以为这样做，程序执行速度会更慢，但实际上更改代码后，重命名总用时35.3856ms，牺牲空间储存换取了执行速度。 每个goroutine中单独定义一个字典 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var ( myFolder string //待处理目录 id string //学号 class string //班级 peopleName string //姓名 chapter string //作业章节 formatChoice string //格式 WG sync.WaitGroup)func main() &#123; ............. //开启协程 go func() &#123; //退出前关闭一个wg defer WG.Done() //fmt.Println(f.Name()) //属于文件，先进行匹配查询，查询成功则重命名 var ok bool peopleName, id, ok = Check.NameCheck(f.Name()) if ok &#123; //作业格式 var format = map[string]string&#123; &quot;0&quot;: id, &quot;1&quot;: peopleName, &quot;2&quot;: class, &quot;3&quot;: chapter, &#125; //新旧文件路径 oldPath := fmt.Sprintf(&quot;%v/%v&quot;, myFolder, f.Name()) newPath := fmt.Sprintf(&quot;%v/%v %v %v %v %v&quot;, myFolder, format[strings.Split(formatChoice, &quot;&quot;)[0]], format[strings.Split(formatChoice, &quot;&quot;)[1]], format[strings.Split(formatChoice, &quot;&quot;)[2]], format[strings.Split(formatChoice, &quot;&quot;)[3]], path.Ext(oldPath)) //重命名 err := os.Rename(oldPath, newPath) if err != nil &#123; fmt.Println(err) &#125; &#125; &#125;() .............&#125; 但是使用“每个goroutine中单独定义一个字典”的方法，在后续的使用中（同学反映），处理某一批文件时，还是出现了并发安全问题。于是我又尝试使用传统的sync.Mutex + map 的方法来解决这个问题。 使用带有锁的map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package mainimport ( &quot;GoRename/Check&quot; &quot;GoRename/Count&quot; &quot;fmt&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;os&quot; &quot;path&quot; &quot;strings&quot; &quot;sync&quot; &quot;time&quot;)//一些变量var ( myFolder string //待处理目录 id string //学号 class string //班级 peopleName string //姓名 chapter string //作业章节 formatChoice string //格式 WG sync.WaitGroup //设置WaitGroup,保证协程全部退出后main再退出)//带有读写锁的maptype RWmap struct &#123; sync.Mutex //锁 m map[string]string&#125;func main() &#123; fmt.Println(&quot;[guide] 请输入要处理的目录路径：(请仔细检查您所填写路径)&quot;) fmt.Scanln(&amp;myFolder) _, err := ioutil.ReadDir(myFolder) for err != nil &#123; fmt.Println(&quot;[warning] 无法读取文件夹，请再次检查路径&quot;) fmt.Println(&quot;[guide] 请再次输入要处理的目录路径：&quot;) fmt.Scanln(&amp;myFolder) _, err = ioutil.ReadDir(myFolder) &#125; fmt.Println(&quot;[guide] 请输入您的班级:&quot;) fmt.Scanln(&amp;class) fmt.Println(&quot;[guide] 请输入作业章节:&quot;) fmt.Scanln(&amp;chapter) fmt.Println(&quot;[guide] 请选择您希望的格式&quot;) fmt.Println(&quot;[menu] [0]学号 [1]姓名 [2]班级 [3]作业章节（备注）&quot;) fmt.Println(&quot;[example] 100001 张三 网络206 第一章作业 对应输入：0123&quot;) fmt.Scanln(&amp;formatChoice) for len(strings.Split(formatChoice, &quot;&quot;)) != 4 &#123; fmt.Println(&quot;[warning] 参数不正确&quot;) fmt.Println(&quot;[guide] 请选择您希望的格式&quot;) fmt.Scanln(&amp;formatChoice) &#125; //计时 startTime := time.Now() //统计指定目录下的文件数量 Count.CountFiles(myFolder) //添加WaitGroup WG.Add(Count.FileNums) files, err := ioutil.ReadDir(myFolder) if err != nil &#123; log.Fatal(&quot;【ERROR】目录读取失败，请检查目录路径\\n&quot;, err) time.Sleep(60 * time.Second) &#125; for _, file := range files &#123; if file.IsDir() &#123; continue //遇到文件夹直接略过 &#125; f := file //开启协程 go func() &#123; //退出前关闭一个wg defer WG.Done() //属于文件，先进行匹配查询，查询成功则重命名 var ok bool peopleName, id, ok = Check.NameCheck(f.Name()) if ok &#123; //fmt.Println(format) //新旧文件路径 oldPath := fmt.Sprintf(&quot;%v/%v&quot;, myFolder, f.Name()) format := RWmap&#123;&#125; //上锁 format.Lock() //作业格式 format.m = map[string]string&#123; &quot;0&quot;: id, &quot;1&quot;: peopleName, &quot;2&quot;: class, &quot;3&quot;: chapter, &#125; newPath := fmt.Sprintf(&quot;%v/%v %v %v %v %v&quot;, myFolder, format.m[strings.Split(formatChoice, &quot;&quot;)[0]], format.m[strings.Split(formatChoice, &quot;&quot;)[1]], format.m[strings.Split(formatChoice, &quot;&quot;)[2]], format.m[strings.Split(formatChoice, &quot;&quot;)[3]], path.Ext(oldPath)) //重命名 err := os.Rename(oldPath, newPath) if err != nil &#123; fmt.Println(err) &#125; //解锁 format.Unlock() &#125; &#125;() &#125; //main主协程等待其他协程完成再退出 WG.Wait() //输出未交作业的名单 Check.SubmittedCheck() endTime := time.Now() fmt.Printf(&quot;[ 总用时 ] %v\\n&quot;, endTime.Sub(startTime)) time.Sleep(2 * 60 * time.Second)&#125;","categories":[{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"}]},{"title":"记一条可疑的日志记录","slug":"PHP扫描","date":"2022-08-18T11:54:44.442Z","updated":"2022-12-20T08:56:17.428Z","comments":true,"path":"2022/08/18/PHP扫描/","link":"","permalink":"http://example.com/2022/08/18/PHP%E6%89%AB%E6%8F%8F/","excerpt":"","text":"某天偶然查看GoManager的项目日志，发现了一条这样的可疑记录 12time=&quot;2022/08/17 - 18:53:23.230946&quot; level=info msg=&quot;| 404 | 100ns | 88.80.186.144 | GET | /?=PHPE9568F36-D428-11d2-A769-00AA001ACF42 |&quot; 我首先查询了访客IP地址的IP属地 是英国伦敦，很奇怪。而且平时日志里的异常记录，基本上都是些不携带QueryString的暴力接口请求，能明显判断出不是普通用户通过项目的前端页面发起的请求，但这个来自国外的请求却携带了一串奇怪的字符串， PHPE9568F36-D428-11d2-A769-00AA001ACF42 在网络安全这块，我几乎是一张白纸，怀疑这是一种攻击手段。 利用“PHP彩蛋”进行敏感信息获取 - canlay - 博客园 (cnblogs.com) 原来这个是PHP低版本中的一个彩蛋，可以被攻击者用以判断站点是否由PHP所构建。 于是我在想，Golang有没有类似的”彩蛋”？搜索引擎搜索”golang彩蛋”，逛了一圈，好像也没有相关的内容。但是搜索”golang漏洞”却发现了一位CTFer的博客，向大牛学习。 golang的一些安全问题 - byc_404’s blog (bycsec.top)","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"GoManager任务管理系统","slug":"GoManager任务管理系统开发","date":"2022-08-18T09:51:46.588Z","updated":"2022-12-20T08:50:59.862Z","comments":true,"path":"2022/08/18/GoManager任务管理系统开发/","link":"","permalink":"http://example.com/2022/08/18/GoManager%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/","excerpt":"","text":"关于项目 一个简易的任务管理系统，适合校园各类部门、社团进行任务发布和管理。 功能实现：1、 实现了各级别用户对个人头像、昵称、邮箱等信息的修改。2、 实现了普通用户、高级用户、管理员的权限区分，普通用户仅允许接收任务，高级用户允许发布任务，管理员允许发布任务和管理用户。3、 实现了高级用户与普通用户之间的任务交互。 4、每位用户都有一块便签区域，可以临时储存一段文本内容。 项目地址 ：https://touchcloud.top:9082DEMO 心路历程 已分享在个人的公众号推送中，欢迎阅读。 996强度的12天里，我经历了什么？ 疑点回顾与分析 1. DB赋值问题 （全局变量初始化时机问题） database包中定义了一个 DB 变量，用来创建gorm的MySQL连接, 类型是*gorm.DB 123456789101112131415161718192021222324252627package databaseimport ( &quot;fmt&quot; &quot;log&quot; &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot;)var ( DB *gorm.DB //注意这里！！！ err error)func InitMySQL() error &#123; //数据库连接字符串 dsn := &quot;xxxxxxxxxxx&quot; //注意这里！！！ DB, err = gorm.Open(mysql.New(mysql.Config&#123; ……………… &#125;), &amp;gorm.Config&#123;&#125;) ………………&#125; 为了使代码更加简洁，在models包中，创建同名变量 DB，并对其赋值database中的DB 123456789101112131415161718192021package models import ( &quot;GoManager/database&quot; &quot;fmt&quot; &quot;time&quot;)var DB = database.DB //注意这里！//UserName查询指定用户func UserNameQuery(username string) (*User, error) &#123; var user User result := DB.Where(&amp;User&#123;UserName: username&#125;).First(&amp;user) //这里！ if result.Error != nil &#123; //fmt.Printf(&quot;%v\\n&quot;, result.Error) return nil, result.Error &#125; return &amp;user, nil&#125; 但是出现了非法内存地址&#x2F;空指针的错误 不使用新的变量，直接使用database包中的DB变量，请求正常，接口正常返回数据 1234567891011121314151617181920package models import ( &quot;GoManager/database&quot; &quot;fmt&quot; &quot;time&quot;)//var DB = database.DB //注意这里！//UserName查询指定用户func UserNameQuery(username string) (*User, error) &#123; var user User result := database.DB.Where(&amp;User&#123;UserName: username&#125;).First(&amp;user) //这里！ if result.Error != nil &#123; //fmt.Printf(&quot;%v\\n&quot;, result.Error) return nil, result.Error &#125; return &amp;user, nil&#125; 参考网上的帖子，楼主的情况和我非常类似， Go使用全局变量要小心闭包 - Go语言中文网 - Golang中文社区 (studygolang.com) 大佬在评论区的评论给了我灵感。 1234567这个问题和闭包没什么关系。var logger = AppLog()这句话使全局变量的初始化，会在main执行之前被执行，此时InitConf显然还没有执行，从而__logger必然是nil，通过AppLog()返回给了logger导致其为nil。之后InitConf虽然把__logger初始化了，但是不会改变logger的值。正确的做法是把InitConf改名成init，变成 package 初始化的一部分。 自我分析： 在models包中新定义的全局变量 DB，已经在main函数执行前初始化，但此时，InitMySQL()函数仍未执行，database.DB为nil，models包中的新定义的全局变量DB也自然为nil。后续database.DB即使初始化完成，models包中的新定义的全局变量DB仍然为nil。 核心问题是全局变量初始化的时机问题。我可以尝试着让InitMySQL()函数成为 database包 初始化的一部分。在main包中的main()函数执行之前，率先执行InitMySQL()，从而实现对全局变量DB的初始化。 init()函数没怎么了解过，当时学习Golang作者的那本Go语言手册时好像也没提到？（也可能是我没留意） 找篇帖子大致了解了一下，Golang的init函数 - 简书 (jianshu.com) 实现包级别变量的初始化，可以考虑init()函数，该函数先于main()函数执行。 将InitMySQL()函数放入 databese包 中的 init()函数，请求正常，接口成功返回数据。 2.Cookie设置问题 cookie必须要在返回JSON响应之前设置好 一开始在返回JSON响应之后才SetCookie，结果在Header里面找了半天都找不到我想设置的cookie，总的来说还是不了解cookie，cookie是http响应头中的一项内容，当然应该伴随响应一起出去。 3.响应返回后及时退出函数问题 返回响应后，要及时退出函数，避免后面设计的变量由于（逻辑）条件不满足，导致出现变量未初始化（nil）问题。","categories":[{"name":"前后端开发","slug":"前后端开发","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"},{"name":"Vue2","slug":"Vue2","permalink":"http://example.com/tags/Vue2/"}]},{"title":"Docker 借助docker-compose安装Redis数据库","slug":"Docker安装Redis数据库","date":"2022-08-18T07:31:15.801Z","updated":"2022-08-18T08:03:55.627Z","comments":true,"path":"2022/08/18/Docker安装Redis数据库/","link":"","permalink":"http://example.com/2022/08/18/Docker%E5%AE%89%E8%A3%85Redis%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"目录结构 在合适的文件夹内创建: 1、一个空文件夹 .&#x2F;data 2、一份yml文件 docker-compose.yml 3、一个文件夹redis.conf 和一个同名的文件 redis.conf 123456.|-- data| `--|-- docker-compose.yml`-- redis.conf `-- redis.conf docker-compose.yml1234567891011121314version: &#x27;3&#x27;services: redis: image: redis:latest container_name: redis restart: always ports: - 3999:6379 volumes: - ./redis.conf:/usr/local/etc/redis/redis.conf:rw - ./data:/data:rw command: /bin/bash -c &quot;redis-server /usr/local/etc/redis/redis.conf/redis.conf&quot; 配置redis.conf文件12345678910111213bind 127.0.0.1 #只绑定本机，如果是在云主机安装redis不建议设置，远程连接会连不上protected-mode noport 6379timeout 0save 900 1 #数据持久化方式RDB的相关配置，分钟级别的保存save 300 10save 60 10000rdbcompression yesdbfilename dump.rdbdir /dataappendonly yes #数据持久化方式AOF，记录用户对数据库的各项命令操作（到文件中）appendfsync everysecrequirepass 你的密码 #添加此项可以为redis配置密码，redis默认无密码 在docker-compose.yml所在目录执行1docker-compose up -d","categories":[{"name":"测试部署","slug":"测试部署","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"Django框架初体验 & 云笔记CloudNote小程序学习","slug":"Django框架初体验 & 云笔记CloudNote小程序学习","date":"2022-08-18T04:56:00.984Z","updated":"2022-12-20T08:42:12.112Z","comments":true,"path":"2022/08/18/Django框架初体验 & 云笔记CloudNote小程序学习/","link":"","permalink":"http://example.com/2022/08/18/Django%E6%A1%86%E6%9E%B6%E5%88%9D%E4%BD%93%E9%AA%8C%20&%20%E4%BA%91%E7%AC%94%E8%AE%B0CloudNote%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"背景 今年2月份开学之后，就开始有一定的专业发展焦虑感，总觉得课堂上的各种理论知识虽然重要，但自身的专业技能远远未能达到企业的要求。我觉得，我一定要“做出点什么东西来”。 一开始的想法是做一个小程序，功能还没有确定，但遵循“先行动起来”的原则，我花了一周半的时间，通过B站的网课学习了小程序的相关内容（包括小程序静态页面的编写和基础的数据渲染）。在学习的过程中，我意识到，想要完成一个完整的小程序，还需要有人做后端，提供json数据，但对于一个初学者来说，我觉得还要去学习后端，一下子有点无从下手（因为学习小程序的时候我是有html、css、js三剑客基础的，但是大佬们口中一直喊的“后端给出接口”，我没有一点概念）。 怀着一种偷懒的心态，又花了四天的时间，学习了一下小程序的“云开发”。按照我的理解，小程序的云开发，本质上就是云服务厂商直接为你提供文件存储和数据库的服务，将开发者从传统的服务器运维、测试部署等繁琐步骤中解放出来（降低了学习成本并且提高了开发效率）。当然，各个云厂商宣传的时候是宣传得挺好的，但真到自己去使用的时候才发现，一个写好的云函数（仅仅是查询数据库的记录），十次执行中有七次都是失败的，这个可靠程度属实让我捏了一把汗。我一直以为是我自己电脑的开发环境有问题，直到我问了别的朋友，发现原来大家都遇到了云函数执行异常的情况，心里多少有点安慰。 学习进度需要推进下去，那我必须去学习后端的相关知识。都说，后端需要选择一门语言，那我应该选择哪一门呢？C++？不了吧，我平时写作业就是用的它，多少有些厌倦了，而且我总是容易犯C++的语法错误。那，诶，不如python ? (我在22年的年初，刚好花过一点时间学习了python的基础语法) python的语法相对简单一些，现成的代码库比较多，用起来很方便。偶然，又看到了某教育机构在B站发的 Django教程，于是便开始学了起来。 Django框架初体验 通过学习Django,我第一次了解到了 路由、中间件、模板、ORM（对象关系映射）等等的后端开发名词，对当前流行的开发架构有了一个初步的了解。 以下理解基于我实际开发的经验 MVC（Model模型层,View视图层，Controller控制器层）。 Model模型层： 1、创建实体，进行数据库Migrate(混合)后，与数据库中的实体形成映射关系。 2、根据业务逻辑，处理对数据库的增删改查操作。 View视图层：渲染提供给用户界面的数据。 Controller控制器层：与用户进行交互，接收用户的对数据库的操作请求。 当然，Python的这个Django框架有一个特有的MVT架构（Model模型层,View视图层，Template模板层），但本质上和MVC大差不差。Template模板层那里就是Django提供了一些特殊的语法，支持在普通的html文件里面渲染动态的数据。 跟着网课的讲解，我终于在Django框架的加持下，写出了我的第一个小小的http服务器，完成了一个基础的用户登录和注册功能（即使是那样一个在生活中常见得不能再常见的东西，也让我高兴了整整一个下午。第一次感受到，自己写的代码能够“转换”成“看得见”的东西。）当然，要把他实现出来也不容易，除了后端对数据库的逻辑处理，前后端的json数据对接，对于初学者的我来说也是相当吃力的。那时，我还不会用Postman这种工具去测试接口，只能在浏览器中一遍又一遍地试错。 云笔记CloudNote小程序 时间来到5月份，自从接触完Django框架之后，没有具体的项目去巩固我的知识点，我的学习进度又开始阻塞起来。由于当时我不会使用前端框架进行页面开发，加之我个人不是很喜欢使用django框架中的模板去进行数据的渲染，所以网课中的“云笔记项目“我只完成了用户登录和注册部分。灵机一动，我为什么不试试小程序呢？很明显，我更熟悉小程序的语法，在html部分使用 wx-for 指令，不就可以把数据列表渲染上去了吗？ 想法有了，立即动手。在五一假期的五天小长假，我花了四天，”沉浸式“地编码，自己写后端接口，自己设计小程序的界面，在代码开发平台和命令行之间反复横跳，怎么这个数据他就是收不到呢？……好在功夫不负有心人，可算是做出了一点小东西。最终，这个小程序实现了用户登录、注册和用户对笔记的创建、修改、删除操作。 总结 暂且不论脚本语言的运行效率，Python确实是一门很适合初学者快速开发、快速看到成效的语言，（弱类型的语言，减少了很多类型定义的繁琐）。暂时感觉不同语言的开发流程大差不差，存在很多的共通点，我们更应该专注于积累开发相关技能和概念，而不是片面地比较哪门语言更好，毕竟术业有专攻，不同的语言适合不同的应用场景。 Django框架是我接触的第一个Web开发框架，算是我的”启蒙老师“，但后来，当我接触了别的框架，回过头来才发现，Django是真的大而全，模板、中间件、数据库连接、数据库缓存、邮箱配置、时区、静态文件储存目录等等，全都给你在配置文件中写得明明白白的。虽然配置Django项目会稍微繁琐一点，但当你跟着配置一遍之后，会对很多概念有一个大致的把握。 写在最后 朋友和我说过这么一句话，”重要的不是你做了这件事情，而是你做这件事情的契机。“，我觉得这句话是真的很有韵味。如果你也突然找到那么一个契机，那便只管放开手去做，成败与否，这段过程中的尝试都会成为你生命里宝贵的财富，很多看似没有意义的付出，往往在不经意之中铺就了未来的道路。","categories":[{"name":"前后端开发","slug":"前后端开发","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"CentOS 7 Zabbix5.0安装笔记（踩坑点）","slug":"Zabbix5.0安装笔记+搭配官方下载指南使用","date":"2022-08-18T03:06:12.847Z","updated":"2022-08-18T07:58:09.922Z","comments":true,"path":"2022/08/18/Zabbix5.0安装笔记+搭配官方下载指南使用/","link":"","permalink":"http://example.com/2022/08/18/Zabbix5.0%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0+%E6%90%AD%E9%85%8D%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%8D%97%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Linux环境： CentOS Linux release 7.9.2009 (Core) Zabbix版本 : 5.0 简介：Zabbix是一套开源的网络管理系统，能够方便地管理各个服务节点。 官网：Zabbix :: The Enterprise-Class Open Source Network Monitoring Solution 从阿里云下载 zabbix5.0 :1rpm -Uvh https://mirrors.aliyun.com/zabbix/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm 更换repo中的yum源,换成阿里云 :1sed -i &#x27;s#http://repo.zabbix.com#https://mirrors.aliyun.com/zabbix#&#x27;/etc/yum.repos.d/zabbix.repo zabbix5.0的环境要求：php要到7以上，否则安装官方指南的一些前端组件会报错！！！ 删除旧版本的php 1yum remove php-common -y 查看可供下载的php包 1yum list *php* 根据清单安装新版本的php 1yum install -y php72w php72w-opcache php72w-xml php72w-mcrypt php72w-gd php72w-devel php72w-mysql php72w-intl php72w-mbstring 改用普通的nginx储存库，而不是redhat的：1yum -y install nginx 【红帽储存库的nginx】里的nginx配置文件（zabbix.conf) 也可以放到【服务器的nginx】里（一会就不用启动rh-nginx116-nginx这个服务） 具体操作如下： 1cp /etc/opt/rh/rh-nginx116/nginx/conf.d/zabbix.conf /etc/nginx/conf.d/ 检测agent是否能连接上：12&gt; zabbix_get -s &#x27;对应的ip&#x27; -p 10050 -k &#x27;agent.ping&#x27;&gt; zabbix_get -s &#x27;对应的ip&#x27; -p 10050 -k &#x27;system.hostname&#x27; 解决图形界面中文乱码：12&gt; yum -y install wqy-microhei-fonts&gt; cp /usr/share/fonts/wqy-microhei/wqy-microhei.ttc /usr/share/fonts/dejavu/DejaVuSans.ttf","categories":[{"name":"测试部署","slug":"测试部署","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Zabbix","slug":"Zabbix","permalink":"http://example.com/tags/Zabbix/"}]},{"title":"Docker 借助docker-compose安装MySQL数据库","slug":"Docker安装MySQL数据库","date":"2022-08-18T02:18:24.677Z","updated":"2022-12-20T08:43:30.079Z","comments":true,"path":"2022/08/18/Docker安装MySQL数据库/","link":"","permalink":"http://example.com/2022/08/18/Docker%E5%AE%89%E8%A3%85MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"docker-compose.yml 配置参考123456789101112131415161718192021version: &#x27;3.1&#x27;services: db: container_name: mysql image: mysql command: --default-authentication-plugin=mysql_native_password ports: - 3030:3306 #端口映射， 暴露在本机的端口：容器内端口 volumes: - ./data:/var/lib/mysql #目录映射， 本机文件目录:docker容器内文件目录 - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro # 时区配置 restart: always #docker重启后，容器自动启动 environment: MYSQL_ROOT_PASSWORD: xxxxxxxxxx #数据库root密码 MYSQL_DATABASE: xxxxxxx #新建的数据库 MYSQL_USER: xx #选择想新建的用户名 MYSQL_PASSWORD: xxxx #为新建用户配置密码 LANG: C.UTF-8 在yml文件所在文件夹下1$ docker-compose up -d my.cnf （var&#x2F;lib&#x2F;mysql) 基础配置123456789101112131415161718192021222324252627282930313233343536373839[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=/usr/local/mysql# 设置mysql数据库的数据的存放目录datadir=/var/lib/mysql/mysqldb# 允许最大连接数max_connections=1000# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=100# 服务端使用的字符集默认为UTF8character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password#是否对sql语句大小写敏感，1表示不敏感 #！！！慎重，在 MySQL 8.0 版本以上 创建数据库后想要再次修改此项，只能重装数据库！！！lower_case_table_names = 1#MySQL连接闲置超过一定时间后(单位：秒)将会被强行关闭#MySQL默认的wait_timeout 值为8个小时, interactive_timeout参数需要同时配置才能生效interactive_timeout = 1800wait_timeout = 1800#Metadata Lock最大时长（秒）， 一般用于控制 alter操作的最大时长sine mysql5.6#执行 DML操作时除了增加innodb事务锁外还增加Metadata Lock，其他alter（DDL）session将阻塞lock_wait_timeout = 3600#内部内存临时表的最大值。#比如大数据量的group by ,order by时可能用到临时表，#超过了这个值将写入磁盘，系统IO压力增大tmp_table_size = 64Mmax_heap_table_size = 64M[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4","categories":[{"name":"测试部署","slug":"测试部署","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"《网络安全法》 学习笔记","slug":"《网络安全法》学习笔记","date":"2022-08-17T14:36:48.490Z","updated":"2022-08-18T07:30:20.346Z","comments":true,"path":"2022/08/17/《网络安全法》学习笔记/","link":"","permalink":"http://example.com/2022/08/17/%E3%80%8A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"《中华人民共和国网络安全法 》(samr.gov.cn) 粗读一遍，记录了一些需要重点关注的地方 (以普通学生的视角)。 我感觉IT行业的从业者始终需要有网络安全的意识，知道底线在哪里。 第二十二条 ​ 网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。 网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。 第二十七条 ​ 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。 第六十三条 ​ 违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。 单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。 第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。 第四十二条 网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。 网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 第四十三条 个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。 第四十八条 ​ 任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。 电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。 第七十六条 本法下列用语的含义: （一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。 （二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。 （三）网络运营者，是指网络的所有者、管理者和网络服务提供者。 （四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。 （五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-17T14:35:58.030Z","updated":"2022-08-17T14:35:58.030Z","comments":true,"path":"2022/08/17/hello-world/","link":"","permalink":"http://example.com/2022/08/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"前后端开发","slug":"前后端开发","permalink":"http://example.com/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"后端开发","slug":"后端开发","permalink":"http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"测试部署","slug":"测试部署","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://example.com/tags/Golang/"},{"name":"Vue2","slug":"Vue2","permalink":"http://example.com/tags/Vue2/"},{"name":"SESSION","slug":"SESSION","permalink":"http://example.com/tags/SESSION/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"Django","slug":"Django","permalink":"http://example.com/tags/Django/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Zabbix","slug":"Zabbix","permalink":"http://example.com/tags/Zabbix/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]}